<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Motion.lua Menu UI</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/@phosphor-icons/web@2.1.1/src/regular/style.css" />
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/@phosphor-icons/web@2.1.1/src/fill/style.css" />
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap');
        
        :root {
            --menu-color: 20, 20, 30; /* Theme 4 color */
            --ui-scale: 0.86; /* overall menu scale */
            --select-blue: 0, 135, 255; /* plaid-like highlight */
            --notif-accent: 180, 0, 255; /* neon purple */
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        /* STRICTLY KEYBOARD-ONLY MENU - NO MOUSE NAVIGATION */
        *:not(.TextInputModal):not(.TextInputModal *) {
            pointer-events: none !important;
            cursor: none !important;
            user-select: none !important;
            -webkit-user-select: none !important;
        }
        
        /* ONLY allow mouse on text input modal */
        .TextInputModal,
        .TextInputModal * {
            pointer-events: auto !important;
            cursor: auto !important;
        }
        
        html {
            color-scheme: normal !important;
            background: transparent !important;
        }
        
        body {
            background: none !important;
            margin: 0;
            font-family: Inter, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            height: 100vh;
            user-select: none !important;
            overflow: hidden !important;
            pointer-events: none !important; /* STRICTLY KEYBOARD-ONLY - NO MOUSE */
            cursor: none !important;
        }
        
        #root {
            height: 100%;
            width: 100%;
            pointer-events: none !important; /* STRICTLY KEYBOARD-ONLY - NO MOUSE */
            cursor: none !important;
        }
        
        .Desc {
            position: absolute;
            display: flex;
            left: 50%;
            bottom: 4vw;
            transform: translate(-50%);
            width: auto;
            height: 1.3021vw;
            background-color: #000c;
            border-radius: .2604vw;
            padding: 14px;
            font-family: Inter;
            font-weight: 180;
            font-size: .651vw;
            color: #fff;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .Desc.show {
            opacity: 1;
        }
        
        .PWrapper {
            position: absolute;
            display: flex !important;
            left: 4vw;
            top: 50%;
            transform: translateY(-50%) scale(var(--ui-scale));
            transform-origin: left center;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            font-family: Inter;
            opacity: 1;
            visibility: visible;
            transition: opacity 0.3s ease;
            pointer-events: none !important; /* STRICTLY KEYBOARD-ONLY - NO MOUSE */
            cursor: none !important;
            border: 0.052vw solid rgba(255,255,255,0.10);
            border-radius: .42vw;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            box-shadow: 0 0 1.2vw rgba(0,0,0,0.65);
            overflow: hidden;
        }
        
        .PWrapper.show {
            opacity: 1 !important;
            visibility: visible !important;
        }
        
        .PElements {
            position: relative;
            display: flex;
            justify-content: flex-start;
            align-items: flex-start;
            flex-direction: row;
            gap: .2604vw;
            margin-top: 0;
            padding-top: 0;
        }
        
        .PScroll {
            position: absolute;
            display: flex;
            left: -.8vw;
            width: .5208vw;
            height: 100%;
            background-color: #000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: .1042vw;
            border-radius: .1042vw;
        }
        
        .PScroll i {
            font-size: .5208vw;
            color: #fff;
        }
        
        .PSProgressWrapper {
            position: relative;
            display: flex;
            width: .2083vw;
            height: 93%;
            justify-content: center;
            align-items: flex-start;
        }
        
        .PSProgress {
            position: relative;
            display: flex;
            width: .2083vw;
            margin-top: .1302vw;
            background-color: rgb(var(--menu-color));
            box-shadow: 0 0 .1042vw .0521vw rgba(var(--menu-color), 1);
            transition: top .25s ease, height .25s ease;
        }
        
        .PRightElements {
            position: relative;
            display: flex;
            width: 19.0104vw;
            justify-content: flex-start;
            align-items: flex-start;
            flex-direction: column;
            margin-top: 0;
            padding-top: 0;
        }
        
        .PBanner {
            position: relative;
            display: flex;
            width: 100%;
            height: 5.4688vw;
            justify-content: center;
            align-items: center;
            border: .0521vw solid black;
            border-top-left-radius: .4167vw;
            border-top-right-radius: .4167vw;
            overflow: hidden;
        }
        
        .PBanner img {
            position: absolute;
            display: flex;
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: center;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }
        
        .PCategories {
    position: relative;
    display: flex;
    width: 100%;
    height: 1.35vw;
    align-items: center;
    padding: 0 .65vw;
    background: rgba(0,0,0,0.62);
    border-top: 0.052vw solid rgba(255,255,255,0.10);
    border-bottom: 0.052vw solid rgba(255,255,255,0.10);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
}
        
        .PCategory {
    font-size: .72vw;
    font-weight: 700;
    color: rgba(255,255,255,0.92);
    letter-spacing: .01vw;
}
        
        .PCategory.active {
            background: linear-gradient(0deg, rgba(var(--menu-color), 0.1) 0%, rgba(var(--menu-color), .1) 100%);
        }
        
        .PCategory:only-child {
            position: absolute;
            display: flex;
            left: 0vw;
            font-size: .625vw;
            padding: 0 .8vw;
            justify-content: flex-start;
        }
        
        .PCategory:last-child {
            border-right: none;
        }
        
        .PTabs {
    position: relative;
    display: flex !important;
    width: 19.0104vw;
    height: auto;
    min-height: 1.5625vw;
    max-height: 14.0vw;
    padding-bottom: .0521vw;
    justify-content: flex-start;
    align-items: flex-start;
    flex-direction: column;
    background: rgba(0,0,0,0.55);
    border-top: 0.052vw solid rgba(255,255,255,0.10);
    border-bottom: 0.052vw solid rgba(255,255,255,0.10);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
}
        
        .PTab {
    position: relative;
    display: flex !important;
    width: 100%;
    height: 1.72vw;
    min-height: 1.72vw;
    max-height: 1.72vw;
    justify-content: space-between;
    align-items: center;
    padding: 0 .65vw;
    visibility: visible;
    opacity: 1;
    pointer-events: none !important; /* keyboard only */
    user-select: none;
    z-index: 2;
    border-top: 0.052vw solid rgba(255,255,255,0.07);
}
        
        .PTLabel {
            position: absolute;
            display: block;
            left: .5vw;
            width: 60%;
            height: 60%;
            font-size: .625vw;
            font-weight: 300;
            color: #fff;
            overflow: hidden;
            text-overflow: ellipsis;
            text-wrap: nowrap;
            white-space: nowrap;
            justify-content: center;
            align-items: center;
        }
        
        .PTab i {
            position: absolute;
            display: flex;
            right: .65vw;
            font-size: .625vw;
            color: #fff;
        }
        
        .Checkbox {
    width: 2.1vw;
    height: .95vw;
    border-radius: 999px;
    background: rgba(255,255,255,0.16);
    border: 0.052vw solid rgba(255,255,255,0.18);
    position: relative;
    flex-shrink: 0;
}
        
        .Checkbox.Checked {
    background: rgba(var(--select-blue), 0.95);
    border-color: rgba(255,255,255,0.25);
    box-shadow: 0 0 .45vw rgba(var(--select-blue), 0.35);
}
        
        .Checkbox.Checked .Inside {
            left: .95vw;
        }
        
        .Checkbox .Inside {
            position: absolute;
            display: flex;
            left: .15vw;
            margin-bottom: .065vw;
            width: .4167vw;
            height: .4167vw;
            background-color: #fff;
            border-radius: .2604vw;
            transition: .25s all;
        }
        
        .Slider {
            position: absolute;
            display: flex;
            right: .65vw;
            width: 2.3438vw;
            height: .2083vw;
            justify-content: flex-start;
            align-items: center;
            background-color: #1e1e1e;
            border-radius: .2604vw;
        }
        
        .Slider .Progress {
            position: absolute;
            display: flex;
            height: 100%;
            justify-content: center;
            align-items: center;
            background: rgb(225, 225, 225);
            border-radius: .2604vw;
        }
        
        .Slider .Progress .Thumb {
            position: absolute;
            display: flex;
            right: 0vw;
            width: .4167vw;
            height: .4167vw;
            background-color: #e1e1e1;
            border-radius: .5208vw;
        }
        
        .Scrollable {
            position: absolute;
            display: flex;
            right: .65vw;
            justify-content: center;
            align-items: center;
            flex-direction: row;
            gap: .2604vw;
            font-size: .625vw;
            font-weight: 250;
            color: #fff;
        }
        
        .TOptions {
            position: absolute;
            display: flex;
            right: .65vw;
            width: 7.8125vw;
            justify-content: flex-end;
            align-items: center;
            flex-direction: row;
            gap: .5208vw;
        }
        
        .TOptions .Scrollable {
            position: relative;
            display: flex;
            right: .15vw;
            justify-content: center;
            align-items: center;
            flex-direction: row;
            gap: .2604vw;
            font-size: .625vw;
            font-weight: 250;
            color: #fff;
        }
        
        .TOptions .Checkbox {
            position: relative;
            display: flex;
            right: 0vw;
            width: 1.5625vw;
            height: .7813vw;
            justify-content: center;
            align-items: center;
            background-color: #1e1e1e;
            border-radius: 5vw;
        }
        
        .TOptions .Checkbox.Checked {
            background: rgb(var(--menu-color));
        }
        
        .TOptions .Checkbox.Checked .Inside {
            left: .95vw;
        }
        
        .TOptions .Slider {
            position: relative;
            display: flex;
            right: .15vw;
            width: 2.3438vw;
            height: .2083vw;
            justify-content: flex-start;
            align-items: center;
            background-color: #1e1e1e;
            border-radius: .2604vw;
        }
        
        .TOptions .Slider .Progress {
            position: absolute;
            display: flex;
            height: 100%;
            justify-content: center;
            align-items: center;
            background: rgb(255, 255, 255);
            border-radius: .2604vw;
        }
        
        .Divider {
            position: absolute;
            left: 50%;
            transform: translate(-50%);
            display: flex;
            width: 92%;
            justify-content: space-between;
            align-items: center;
            flex-direction: row;
            gap: .2604vw;
        }
        
        .Divider .Left, .Divider .Right {
            position: relative;
            display: flex;
            width: 15%;
            height: .2083vw;
            background-color: #e1e1e1;
            border-radius: 5vw;
            min-width: 0;
        }
        
        .Divider .Label {
            position: relative;
            display: flex;
            font-size: .625vw;
            font-weight: 300;
            color: #e1e1e1;
            white-space: nowrap;
            padding: 0 .5vw;
        }
        
        .Metadata {
            position: absolute;
            display: flex;
            width: 13.8021vw;
            right: -14.25vw;
            top: 0vw;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: .2083vw;
            background-color: #0f0f0fe6;
            border-radius: .2604vw;
            padding: .5208vw;
            opacity: 0;
            transform: translateX(20px);
            transition: opacity 0.2s ease, transform 0.2s ease;
        }
        
        .Metadata.show {
            opacity: 1;
            transform: translateX(0);
        }
        
        .Metadata .Title {
            position: relative;
            display: flex;
            width: 98%;
            height: .7813vw;
            justify-content: flex-start;
            align-items: center;
            color: #fffc;
        }
        
        .Metadata .Title span {
            display: block;
            width: 100%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-family: Inter;
            font-style: normal;
            font-weight: 350;
            font-size: .625vw;
            line-height: .7813vw;
            text-align: center;
        }
        
        .Metadata .Line {
            position: relative;
            display: flex;
            width: 98%;
            height: .013vw;
            margin-top: .2083vw;
            background-color: #ffffff40;
        }
        
        .Metadata .Values {
            position: relative;
            display: flex;
            width: 98%;
            margin-top: .3125vw;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: .2604vw;
        }
        
        .Metadata .Value {
            position: relative;
            display: flex;
            width: 100%;
            justify-content: flex-start;
            align-items: center;
        }
        
        .Metadata .Key {
            position: relative;
            display: flex;
            height: .7813vw;
            font-family: Inter;
            font-style: normal;
            font-weight: 250;
            font-size: .625vw;
            line-height: .7813vw;
            align-items: center;
            color: #fff;
        }
        
        .Metadata .Val {
            position: absolute;
            display: flex;
            right: 0vw;
            justify-content: flex-end;
            align-items: center;
            flex-direction: row;
            gap: .2604vw;
        }
        
        .Metadata .Val span {
            height: .7813vw;
            font-family: Inter;
            font-style: normal;
            font-weight: 250;
            font-size: .625vw;
            line-height: .7813vw;
            align-items: center;
            color: #fff;
        }
        
        .Metadata .Status {
            position: relative;
            display: flex;
            width: .2604vw;
            height: .7813vw;
            background-color: #000;
            border-radius: .0781vw;
            justify-content: center;
            align-items: flex-end;
            overflow: hidden;
        }
        
        .Metadata .Status .Progress {
            position: absolute;
            display: flex;
            width: 100%;
            bottom: 0vw;
            transition: .25s height;
        }
        
        .PFooter {
            position: relative;
            display: flex;
            width: 19.0104vw;
            height: 1.5625vw;
            margin-top: .2083vw;
            justify-content: center;
            align-items: center;
            background-color: #000;
            border-radius: .3125vw;
        }
        
        .PBuild {
            position: absolute;
            display: flex;
            left: .5vw;
            font-size: .625vw;
            font-weight: 250;
            color: #fff;
        }
        
        .PIndicator {
            position: absolute;
            display: flex;
            right: .5vw;
            font-size: .625vw;
            font-weight: 250;
            color: #fff;
        }
        
        .Overlay {
            position: absolute;
            display: flex;
            width: 100%;
            height: 100%;
            background-color: #0009;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        
        .Overlay.show {
            opacity: 1;
        }
        
        .InputWrapper {
            position: absolute;
            left: 50%;
            bottom: 8vw;
            width: 26.0417vw;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transform: translateX(-50%);
            background-color: #00000080;
            border-radius: .26vw;
            overflow: hidden;
            font-family: Inter;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        
        .InputWrapper.show {
            opacity: 1;
        }
        
        .InputWrapper .Header {
            width: 100%;
            height: 1.3vw;
            display: flex;
            align-items: center;
            gap: .26vw;
            padding-left: .3vw;
            border-bottom: .052vw solid rgb(var(--menu-color));
            background: rgba(0, 0, 0, 0.705);
            color: #fff;
            font-size: .62vw;
            font-weight: 300;
        }
        
        .InputWrapper .Header i {
            margin-left: .5vw;
        }
        
        .InputWrapper .Body {
            width: 100%;
            height: 1.82vw;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #a7a7a717;
            color: #fff;
            font-size: .62vw;
            font-weight: 300;
        }
        
        @keyframes blink {
            to { visibility: hidden; }
        }
        
        .NotificationsWrapper {
    position: fixed;
    top: 1.1vw;
    right: 1.1vw;
    display: flex;
    flex-direction: column;
    gap: .45vw;
    z-index: 9999;
    pointer-events: none;
}

.Notification {
    background-color: rgba(10, 10, 14, 0.92); /* hard matte black */
    border: .0521vw solid rgba(var(--notif-accent), 0.55);
    border-radius: .52vw;
    padding: .42vw .58vw;
    width: 13.2vw;
    min-width: 13.2vw;
    display: flex;
    flex-direction: row;
    gap: .45vw;
    align-items: center;
    color: #fff;
    position: relative;
    font-family: Inter;
    pointer-events: auto;
    opacity: 0;
    transform: translateX(140%);
    transition: opacity .18s ease, transform .45s ease;
    box-shadow: 0 0 .65vw rgba(var(--notif-accent), 0.15);
    backdrop-filter: blur(6px);
    -webkit-backdrop-filter: blur(6px);
}

.Notification.enter {
    opacity: 1;
    transform: translateX(0);
}

.Notification.exit {
    opacity: 0;
    transform: translateX(40%);
}
        
        .Notification i {
    margin-left: .2vw;
    font-size: .95vw;
    flex-shrink: 0;
}
        
        .NotificationBorder {
    position: absolute;
    top: .35vw;
    left: .35vw;
    width: .16vw;
    height: calc(100% - .70vw);
    border-radius: .22vw;
    background: rgb(var(--notif-accent));
    box-shadow: 0 0 .65vw rgba(var(--notif-accent), 0.55);
}
        
        .NotificationContent {
            display: flex;
            flex-direction: column;
            gap: .25rem;
            flex: 1;
            min-width: 0;
        }
        
        .NotificationTitle {
    font-size: .66vw;
    font-weight: 700;
    letter-spacing: .01vw;
}
        
        .NotificationDesc {
    font-size: .58vw;
    word-wrap: break-word;
    color: rgba(255,255,255,0.72);
    line-height: 1.25;
}
        
        .NotificationProgress {
    position: absolute;
    left: .35vw;
    right: .35vw;
    bottom: .28vw;
    height: .14vw;
    border-radius: .2vw;
    background-color: rgb(var(--notif-accent));
    animation-name: progress;
    animation-timing-function: linear;
}
        
        @keyframes progress {
            0% { width: 100%; }
            to { width: 0%; }
        }
        
        .KBLWrapper {
            position: absolute;
            display: flex;
            right: 1.0417vw;
            top: 1.0417vw;
            width: 7.0313vw;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            font-family: Inter;
            border-radius: .1563vw;
            overflow: hidden;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        
        .KBLWrapper.show {
            opacity: 1;
        }
        
        .KBLWrapper .Header {
            position: relative;
            display: flex;
            width: 100%;
            height: 1.0417vw;
            justify-content: flex-start;
            align-items: center;
            background-color: #000c;
            border-bottom: .0521vw solid rgb(var(--menu-color));
        }
        
        .KBLWrapper .Header span {
            margin-left: .1042vw;
            font-size: .5208vw;
            font-weight: 350;
            color: #fff;
        }
        
        .KBLWrapper .Keybinds {
            position: relative;
            display: flex;
            width: 100%;
            height: auto;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: .2083vw;
            background-color: #00000080;
            padding: .1042vw;
        }
        
        .KBLWrapper .Keybind {
            position: relative;
            display: flex;
            width: 100%;
            height: .7813vw;
            justify-content: flex-start;
            align-items: center;
        }
        
        .KBLWrapper .Label {
            position: absolute;
            display: flex;
            left: .25vw;
            font-size: .5208vw;
            font-weight: 350;
            color: #fff;
        }
        
        .KBLWrapper .Elements {
            position: absolute;
            display: flex;
            right: .25vw;
            justify-content: flex-end;
            align-items: center;
            flex-direction: row;
            gap: .1042vw;
        }
        
        .KBLWrapper .Elements span {
            font-size: .5208vw;
            font-weight: 350;
            color: #fff;
        }
        
        .highlight {
    position: absolute;
    width: calc(100% - 0.0vw);
    left: 0;
    background: linear-gradient(90deg,
        rgba(var(--select-blue), 0.95),
        rgba(var(--select-blue), 0.55)
    );
    border: 0.052vw solid rgba(255,255,255,0.18);
    border-radius: .16vw;
    box-shadow: 0 0 .55vw rgba(var(--select-blue), 0.35);
    z-index: 1;
    transition: none !important;
}
        
        .vehicle-icon {
            position: absolute;
            display: flex;
            right: 2.8vw;
            width: 18px;
            height: 18px;
        }
        
        ::-webkit-scrollbar {
            background-color: transparent;
            padding: 0;
            margin: 0;
            width: 0;
            height: 0;
        }
    </style>
  </head>
  <body>
    <div id="root">
        <!-- Description Box -->
        <div id="descBox" class="Desc"></div>
        
        <!-- Main Menu Wrapper -->
        <div id="menuWrapper" class="PWrapper show">
            <div class="PBanner">
                <img id="bannerImage" src="https://raw.githubusercontent.com/MotionLua/motion-banners/refs/heads/main/theme4.png" draggable="false" alt="Banner">
            </div>
            
            <div class="PElements">
                <div class="PRightElements">
                    <div class="PScroll">
                        <i class="fa-solid fa-angle-up"></i>
                        <div class="PSProgressWrapper">
                            <div id="scrollProgress" class="PSProgress"></div>
                        </div>
                        <i class="fa-solid fa-angle-down"></i>
                    </div>
                    
                    <div id="categoriesContainer" class="PCategories">
                        <div class="PCategory active">Main Menu</div>
                    </div>
                    
                    <div class="PTabs" id="tabsContainer">
                        <div id="highlight" class="highlight"></div>
                    </div>
                    
                    <div class="PFooter">
                        <span class="PBuild">Motion.lua (v1.0.0)</span>
                        <span id="indicator" class="PIndicator">(0/0)</span>
                    </div>
                </div>
                
                <div id="metadataContainer" class="Metadata"></div>
            </div>
        </div>
        
        <!-- Input Wrapper -->
        <div id="inputWrapper" class="InputWrapper">
            <div class="Header">
                <i class="fa-solid fa-info"></i>
                <span id="inputTitle">Keyboard Input</span>
            </div>
            <div class="Body">
                <span id="inputValue">Value</span>
            </div>
        </div>
        
        <!-- Overlay -->
        <div id="overlay" class="Overlay"></div>
        
        <!-- Notifications -->
        <div id="notificationsContainer" class="NotificationsWrapper"></div>
        
        <!-- Keybinds -->
        <div id="keybindsContainer" class="KBLWrapper">
            <div class="Header">
                <span>Keybinds</span>
            </div>
            <div class="Keybinds" id="keybindsList"></div>
        </div>
    </div>

    <script>
        // ===================== GLOBAL STATE =====================

// PS3-ish UI tick (pure WebAudio, no external files)
let __uiAudioCtx = null;
function playUiTick() {
    try {
        if (!__uiAudioCtx) __uiAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const ctx = __uiAudioCtx;

        const now = ctx.currentTime;

        // short click + swoop
        const o1 = ctx.createOscillator();
        const g1 = ctx.createGain();
        o1.type = "triangle";
        o1.frequency.setValueAtTime(880, now);
        o1.frequency.exponentialRampToValueAtTime(660, now + 0.07);
        g1.gain.setValueAtTime(0.0001, now);
        g1.gain.exponentialRampToValueAtTime(0.12, now + 0.01);
        g1.gain.exponentialRampToValueAtTime(0.0001, now + 0.09);
        o1.connect(g1).connect(ctx.destination);
        o1.start(now);
        o1.stop(now + 0.10);

        // tiny noise burst for "ui click"
        const bufferSize = 0.06 * ctx.sampleRate;
        const buffer = ctx.createBuffer(1, bufferSize|0, ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * (1 - i / data.length);
        const noise = ctx.createBufferSource();
        noise.buffer = buffer;
        const ng = ctx.createGain();
        ng.gain.setValueAtTime(0.0001, now);
        ng.gain.exponentialRampToValueAtTime(0.06, now + 0.005);
        ng.gain.exponentialRampToValueAtTime(0.0001, now + 0.05);
        noise.connect(ng).connect(ctx.destination);
        noise.start(now);
        noise.stop(now + 0.06);
    } catch (e) {
        // ignore (autoplay policies etc.)
    }
}

        // ===================== GLOBAL STATE =====================
        let menuVisible = false;
        let elements = [];
        let selectedIndex = 0;
        let history = [];
        let categories = null;
        let categoryIndex = 0;
        // Banner images for themes 1-4 (updated with permanent GitHub links)
        let banner = {
            link: "https://raw.githubusercontent.com/MotionLua/motion-banners/refs/heads/main/theme1.png", // Theme 1
            color: "168, 25, 56",
            highlightColor: "255, 200, 150" // Highlight color for theme
        };
        
        // Theme banner links (for theme selector)
        const themeBanners = {
            1: "https://raw.githubusercontent.com/MotionLua/motion-banners/refs/heads/main/theme1.png",
            2: "https://raw.githubusercontent.com/MotionLua/motion-banners/refs/heads/main/theme2.png",
            3: "https://raw.githubusercontent.com/MotionLua/motion-banners/refs/heads/main/theme.png",
            4: "https://raw.githubusercontent.com/MotionLua/motion-banners/refs/heads/main/theme4.png",
            5: "https://raw.githubusercontent.com/MotionLua/motion-banners/refs/heads/main/theme5.png"
        };
        let username = "Player";
        let tabRefs = [];
        let notificationId = 0;
        
        // ===================== UTILITY FUNCTIONS =====================
        function isEnvBrowser() {
            return !window.invokeNative;
        }
        
        function fetchNui(eventName, data, mockData) {
            if (isEnvBrowser() && mockData) return Promise.resolve(mockData);
            
            const resourceName = window.GetParentResourceName ? window.GetParentResourceName() : 'nui-frame-app';
            return fetch(`https://${resourceName}/${eventName}`, {
                method: 'post',
                headers: { 'Content-Type': 'application/json; charset=UTF-8' },
                body: JSON.stringify(data)
            }).then(resp => resp.json());
        }
        
        // Send message to Lua via MachoCreateDui
        // For MachoCreateDui, we store messages for Lua to poll
        function sendToLua(action, data) {
            // Store message for Lua to poll (CRITICAL for MachoCreateDui)
            window._pendingLuaMessage = {
                action: action,
                data: data || {}
            };
            
            console.log("[Motion.Lua] Stored message for Lua:", action, data);
            
            // Also try window.parent.postMessage for direct communication
            if (window.parent && window.parent !== window) {
                try {
                    window.parent.postMessage({
                        action: action,
                        ...data
                    }, '*');
                } catch (e) {
                    console.error("Failed to send message to parent:", e);
                }
            }
            
            // Also try NUI callback for compatibility (standard FiveM NUI)
            if (!isEnvBrowser()) {
                try {
                    fetchNui(action, data).catch(() => {});
                } catch (e) {
                    console.error("Failed to send via fetchNui:", e);
                }
            }
        }
        
        // ===================== MENU RENDERING =====================
        // OPTIMIZED: Instant highlight with zero delays - uses direct style manipulation
        const ITEM_HEIGHT_VW = 1.5625; // Fixed height per item in vw units
        const ITEM_HEIGHT_PX = ITEM_HEIGHT_VW * (window.innerWidth / 100); // Pre-calculate in pixels
        
        function updateHighlight() {
            if (!menuVisible || elements.length === 0 || selectedIndex < 0 || selectedIndex >= elements.length) {
                const highlight = document.getElementById('highlight');
                if (highlight) {
                    highlight.style.display = 'none';
                    highlight.style.transition = 'none';
                }
                return;
            }
            
            const highlight = document.getElementById('highlight');
            if (!highlight) return;
            
            // Calculate position directly from selectedIndex - INSTANT, NO DELAYS
            const topPosition = selectedIndex * ITEM_HEIGHT_VW;
            
            // Apply ALL styles DIRECTLY - no requestAnimationFrame for zero delay
            const highlightColor = banner.highlightColor || banner.color || '168, 25, 56';
            highlight.style.top = `${topPosition}vw`;
            highlight.style.height = `${ITEM_HEIGHT_VW}vw`;
            highlight.style.display = 'block';
            highlight.style.opacity = '1';
            highlight.style.visibility = 'visible';
            highlight.style.transition = 'none';
            highlight.style.transform = 'translateZ(0)';
            highlight.style.backgroundColor = `rgba(${highlightColor}, 0.60)`;
            highlight.style.borderColor = `rgba(${highlightColor}, 1)`;
            highlight.style.boxShadow = `0vw 0vw .2083vw .0339vw rgb(${highlightColor})`;
            
            // Scroll container instantly - no smooth scrolling
            const container = document.getElementById('tabsContainer');
            if (container) {
                const containerHeight = 14.0625; // max-height in vw
                const visibleItems = Math.floor(containerHeight / ITEM_HEIGHT_VW);
                const scrollPosition = Math.max(0, selectedIndex - Math.floor(visibleItems / 2));
                const scrollTopPx = scrollPosition * ITEM_HEIGHT_PX;
                container.style.scrollBehavior = 'auto'; // Ensure no smooth scrolling
                container.scrollTop = scrollTopPx; // Instant scroll, no smooth behavior
            }
        }
        
        function updateScrollbar() {
            const progress = document.getElementById('scrollProgress');
            if (!progress || elements.length === 0) return;
            
            const visibleHeight = Math.floor(14.0625 / 1.5625);
            const totalTabs = elements.filter(el => el.type !== "divider").length;
            const currentVisibleIndex = elements.filter(el => el.type !== "divider").indexOf(elements[selectedIndex]);
            
            if (totalTabs <= visibleHeight) {
                progress.style.height = "97%";
                progress.style.top = "0%";
            } else {
                const heightPercent = (visibleHeight / totalTabs) * 100;
                const topPercent = (currentVisibleIndex / totalTabs) * (100 - heightPercent);
                progress.style.height = `${heightPercent}%`;
                progress.style.top = `${topPercent}%`;
            }
        }
        
        function renderCategories() {
            const container = document.getElementById('categoriesContainer');
            if (!container) return;
            
            if (categories && categories.length > 0) {
                container.innerHTML = categories.map((cat, idx) => 
                    `<div class="PCategory ${idx === categoryIndex ? 'active' : ''}">${cat.label}</div>`
                ).join('');
            } else {
                container.innerHTML = '<div class="PCategory active">Main Menu</div>';
            }
        }
        
        function renderTabs() {
            const container = document.getElementById('tabsContainer');
            if (!container) {
                console.error("[Motion.Lua] tabsContainer not found!");
                return;
            }
            
            tabRefs = [];
            container.innerHTML = '<div id="highlight" class="highlight"></div>';
            
            // Ensure elements is an array
            if (!Array.isArray(elements)) {
                console.warn("[Motion.Lua] elements is not an array:", typeof elements);
                elements = [];
            }
            
            // Debug log
            if (elements.length === 0) {
                console.warn("[Motion.Lua] No elements to render!");
            } else {
                console.log(`[Motion.Lua] Rendering ${elements.length} tabs`);
            }
            
            elements.forEach((element, index) => {
                // Skip if element is null/undefined
                if (!element) {
                    console.warn(`[Motion.Lua] Element at index ${index} is null/undefined`);
                    return;
                }
                
                const tab = document.createElement('div');
                tab.className = `PTab ${index === selectedIndex ? 'active' : ''}`;
                tabRefs.push(tab);
                
                // Get label text - handle subMenu type specially
                let labelText = element.label || 'Unknown';
                
                if (element.type !== "divider") {
                    const label = document.createElement('span');
                    label.className = 'PTLabel';
                    
                    if (index === selectedIndex && element.type === "slider") {
                        labelText = `${element.label}: ${element.value}`;
                    } else if (index === selectedIndex && element.type === "slider-checkbox") {
                        labelText = `${element.label}: ${element.value}`;
                    }
                    
                    label.innerHTML = labelText + (element.hazardous ? ' <span style="color: #fcb603;">⚠️</span>' : '');
                    tab.appendChild(label);
                }
                
                // Add arrow icon for subMenu type
                if (element.type === "subMenu" || element.categories) {
                    const icon = document.createElement('i');
                    icon.className = 'fa-solid fa-angle-right';
                    tab.appendChild(icon);
                }
                
                if (element.type === "checkbox") {
                    const checkbox = document.createElement('div');
                    checkbox.className = `Checkbox ${element.checked ? 'Checked' : ''}`;
                    checkbox.innerHTML = '<div class="Inside"></div>';
                    tab.appendChild(checkbox);
                }
                
                if (element.type === "slider") {
                    const slider = document.createElement('div');
                    slider.className = 'Slider';
                    const width = element.max && element.min !== undefined
                        ? ((element.value - element.min) / (element.max - element.min)) * 100
                        : element.value;
                    slider.innerHTML = `<div class="Progress" style="width: ${width}%"><div class="Thumb"></div></div>`;
                    tab.appendChild(slider);
                }
                
                if (element.type === "slider-checkbox") {
                    const options = document.createElement('div');
                    options.className = 'TOptions';
                    const width = element.max && element.min !== undefined
                        ? ((element.value - element.min) / (element.max - element.min)) * 100
                        : element.value;
                    options.innerHTML = `
                        <div class="Slider">
                            <div class="Progress" style="width: ${width}%; transition: 0.5s width;">
                                <div class="Thumb"></div>
                            </div>
                        </div>
                        <div class="Checkbox ${element.checked ? 'Checked' : ''}">
                            <div class="Inside"></div>
                        </div>
                    `;
                    tab.appendChild(options);
                }
                
                if (element.type === "scrollable-checkbox") {
                    const options = document.createElement('div');
                    options.className = 'TOptions';
                    let displayValue = '';
                    // Lua sends value as 1-based index, HTML arrays are 0-based
                    if (element.values && Array.isArray(element.values) && element.value !== undefined) {
                        const index = Math.max(0, Math.min(element.values.length - 1, (element.value || 1) - 1));
                        displayValue = element.values[index] || '';
                    } else if (element.options && Array.isArray(element.options) && element.selected !== undefined) {
                        const option = element.options[element.selected];
                        displayValue = option ? (option.label || option.value || option) : '';
                    }
                    options.innerHTML = `
                        <div class="Scrollable">
                            <span>-</span>
                            <span>${displayValue}</span>
                            <span>-</span>
                        </div>
                        <div class="Checkbox ${element.checked ? 'Checked' : ''}">
                            <div class="Inside"></div>
                        </div>
                    `;
                    tab.appendChild(options);
                }
                
                if (element.type === "scrollable") {
                    const scrollable = document.createElement('div');
                    scrollable.className = 'Scrollable';
                    let displayValue = '';
                    // Lua sends value as 1-based index, HTML arrays are 0-based
                    if (element.values && Array.isArray(element.values) && element.value !== undefined) {
                        const index = Math.max(0, Math.min(element.values.length - 1, (element.value || 1) - 1));
                        displayValue = element.values[index] || '';
                    } else if (element.options && Array.isArray(element.options) && element.selected !== undefined) {
                        const option = element.options[element.selected];
                        displayValue = option ? (option.label || option.value || option) : '';
                    }
                    scrollable.innerHTML = `<span>-</span><span>${displayValue}</span><span>-</span>`;
                    tab.appendChild(scrollable);
                }
                
                if (element.type === "divider") {
                    const divider = document.createElement('div');
                    divider.className = 'Divider';
                    divider.innerHTML = `
                        <div class="Left"></div>
                        <span class="Label">${element.label}</span>
                        <div class="Right"></div>
                    `;
                    tab.appendChild(divider);
                }
                
                if (element.vehicle !== undefined) {
                    const icon = document.createElement('svg');
                    icon.className = 'vehicle-icon';
                    icon.style.color = element.isDriver ? `rgb(${banner.color})` : '#df2929ff';
                    icon.innerHTML = '<path d="M18.92 6.01C18.72 5.42 18.16 5 17.5 5h-11c-.66 0-1.21.42-1.42 1.01L3 12v8c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-1h12v1c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-8l-2.08-5.99zM6.5 16c-.83 0-1.5-.67-1.5-1.5S5.67 13 6.5 13s1.5.67 1.5 1.5S7.33 16 6.5 16zm11 0c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zM5 11l1.5-4.5h11L19 11H5z"/>';
                    tab.appendChild(icon);
                }
                
                container.appendChild(tab);
            });
            
            // Update highlight immediately - no need for requestAnimationFrame with index-based positioning
            updateHighlight();
            updateScrollbar();
            updateIndicator();
        }
        
        function updateIndicator() {
            const indicator = document.getElementById('indicator');
            if (!indicator) return;
            
            const nonDividers = elements.filter(el => el.type !== "divider");
            const currentPos = nonDividers.indexOf(elements[selectedIndex]) + 1;
            const total = nonDividers.length;
            indicator.textContent = `(${currentPos}/${total})`;
        }
        
        function renderMetadata() {
            const container = document.getElementById('metadataContainer');
            if (!container) return;
            
            const element = elements[selectedIndex];
            if (element && element.metaData && element.metaData.length > 0) {
                container.innerHTML = `
                    <div class="Title"><span>${element.name || ''}</span></div>
                    <div class="Line"></div>
                    <div class="Values">
                        ${element.metaData.map(data => `
                            <div class="Value">
                                <div class="Key">${data.key}</div>
                                <div class="Val">
                                    <span style="color: ${data.key === 'Weapon' ? '#D82325' : ''}">${data.value}</span>
                                    ${(data.key === "Health" || data.key === "Armour") ? `
                                        <div class="Status" style="background-color: rgba(${data.color}, 0.25);">
                                            <div class="Progress" style="height: ${parseInt(data.value)}%; background-color: rgb(${data.color});"></div>
                                        </div>
                                    ` : ''}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
                container.classList.add('show');
            } else {
                container.classList.remove('show');
            }
        }
        
        function renderDescription() {
            const descBox = document.getElementById('descBox');
            if (!descBox) return;
            
            const element = elements[selectedIndex];
            if (element && element.desc) {
                let descText = element.desc;
                if (element.hazardous) descText += ' <span style="color: #fcb603;">(Some servers may detect this module)</span>';
                if (element.locked) descText += ' <span style="color: #fc0303ff;">(Locked/Disabled)</span>';
                descBox.innerHTML = `<span>${descText}</span>`;
                descBox.classList.add('show');
            } else {
                descBox.classList.remove('show');
            }
        }
        
        // ===================== MENU VISIBILITY =====================
        function showMenu(visible) {
            menuVisible = visible;
            const wrapper = document.getElementById('menuWrapper');
            if (wrapper) {
                if (visible) {
                    wrapper.style.display = 'flex';
                    wrapper.style.visibility = 'visible';
                    wrapper.style.opacity = '1';
                    wrapper.classList.add('show');
                } else {
                    wrapper.style.opacity = '0';
                    wrapper.classList.remove('show');
                    setTimeout(() => {
                        wrapper.style.visibility = 'hidden';
                        categoryIndex = 0;
                        categories = null;
                        renderCategories();
                    }, 300);
                }
            }
        }
        
        // ===================== KEYBOARD NAVIGATION =====================
        function handleKeyDown(event) {
            // DELETE key is handled COMPLETELY by Lua - don't interfere here
            // Lua uses RegisterKeyMapping + IsControlJustPressed fallback
            const isDelete = event.keyCode === 46 || event.key === "Delete";
            const isCapsLock = event.keyCode === 20 || event.key === "CapsLock";
            
            // Let DELETE/CapsLock pass through to Lua - don't block it
            if (isDelete || isCapsLock) {
                // Don't prevent default - let Lua handle it
                return;
            }
            
            // ALLOWED KEYS ONLY: ArrowUp, ArrowDown, ArrowLeft, ArrowRight, Enter, Backspace, Q, E
            const allowedKeys = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Enter", "Backspace", "q", "Q", "e", "E"];
            const isAllowed = allowedKeys.includes(event.key);
            
            // COMPLETELY BLOCK S, Z keys - no exceptions (CRITICAL: S key was closing menu)
            const isS = event.keyCode === 83 || event.key === "s" || event.key === "S";
            const isZ = event.keyCode === 90 || event.key === "z" || event.key === "Z";
            if (isS || isZ) {
                event.preventDefault();
                event.stopPropagation();
                event.stopImmediatePropagation();
                return false;
            }
            
            // DELETE key is handled at the top of function - don't block it here
            // Lua handles menu toggle via RegisterKeyMapping
            
            // COMPLETELY BLOCK E key - only allow it for scrollables when menu is open AND on scrollable
            const isE = event.keyCode === 69 || event.key === "e" || event.key === "E";
            if (isE) {
                // Only allow E if menu is open AND we're on a scrollable element
                if (menuVisible) {
                    const currentElement = elements[selectedIndex];
                    if (currentElement && (currentElement.type === "scrollable" || currentElement.type === "scrollable-checkbox")) {
                        // Allow E for scrollables - continue to switch statement
                    } else {
                        // Block E if not on scrollable
                        event.preventDefault();
                        event.stopPropagation();
                        event.stopImmediatePropagation();
                        return false;
                    }
                } else {
                    // Block E when menu is closed
                    event.preventDefault();
                    event.stopPropagation();
                    event.stopImmediatePropagation();
                    return false;
                }
            }
            
            // Block all other keys that aren't allowed when menu is visible
            if (!isAllowed && menuVisible) {
                event.preventDefault();
                event.stopPropagation();
                return;
            }
            
            if (!menuVisible) return;
            
            // Skip if typing in input
            if (document.activeElement && document.activeElement.tagName === 'INPUT') {
                return;
            }
            
            switch(event.key) {
                case "ArrowUp":
                    event.preventDefault();
                    event.stopPropagation();
                    if (elements.length > 0) {
                        // Skip dividers - optimized loop
                        let newIndex = selectedIndex;
                        let attempts = 0;
                        const maxAttempts = elements.length;
                        do {
                            newIndex = (newIndex - 1 + elements.length) % elements.length;
                            attempts++;
                        } while (attempts < maxAttempts && elements[newIndex] && elements[newIndex].type === "divider" && newIndex !== selectedIndex);
                        
                        selectedIndex = newIndex;
                        // Update highlight INSTANTLY before anything else
                        updateHighlight();
                        // Then update menu (highlight already done, so no lag)
                        updateMenu();
                    }
                    break;
                case "ArrowDown":
                    event.preventDefault();
                    event.stopPropagation();
                    if (elements.length > 0) {
                        // Skip dividers - optimized loop
                        let newIndex = selectedIndex;
                        let attempts = 0;
                        const maxAttempts = elements.length;
                        do {
                            newIndex = (newIndex + 1) % elements.length;
                            attempts++;
                        } while (attempts < maxAttempts && elements[newIndex] && elements[newIndex].type === "divider" && newIndex !== selectedIndex);
                        
                        selectedIndex = newIndex;
                        // Update highlight INSTANTLY before anything else
                        updateHighlight();
                        // Then update menu (highlight already done, so no lag)
                        updateMenu();
                    }
                    break;
                case "Enter":
                    event.preventDefault();
                    const selected = elements[selectedIndex];
                    if (selected) {
                        if (selected.type === "subMenu" && selected.categories && selected.categories.length > 0) {
                            history.push({
                                tabs: elements,
                                categories: categories,
                                categoryIndex: categoryIndex,
                                selectedIndex: selectedIndex
                            });
                            categories = selected.categories;
                            categoryIndex = 0;
                            elements = selected.categories[0].tabs || [];
                            selectedIndex = 0;
                            updateMenu();
                            
                            // Send message back to Lua
                            sendToLua("menuAction", {
                                action: "enterSubmenu",
                                label: selected.label
                            });
                        } else if (selected.type === "button") {
                            // Execute button action
                            sendToLua("menuAction", {
                                action: "button",
                                index: selectedIndex,
                                label: selected.label
                            });
                        } else if (selected.type === "slider" || selected.type === "slider-checkbox") {
                            // Commit slider value ONLY on Enter
                            sendToLua("menuAction", {
                                action: "select",
                                index: selectedIndex,
                                label: selected.label,
                                type: "slider",
                                value: selected.value
                            });
                        } else if (selected.type === "scrollable" || selected.type === "scrollable-checkbox") {
                            // Commit scrollable selection ONLY on Enter
                            const v = (selected.value !== undefined) ? selected.value : (selected.selected !== undefined ? (selected.selected + 1) : 1);
                            sendToLua("menuAction", {
                                action: "select",
                                index: selectedIndex,
                                label: selected.label,
                                type: "scrollable",
                                value: v
                            });
                        } else if (selected.type === "checkbox") {
                            // Toggle checkbox - CRITICAL: Update state immediately
                            const wasChecked = selected.checked || false;
                            selected.checked = !wasChecked;
                            
                            // Update UI immediately
                            updateMenu();
                            
                            // Send to Lua with proper action format
                            sendToLua("menuAction", {
                                action: "select",
                                index: selectedIndex,
                                label: selected.label,
                                checked: selected.checked,
                                type: "checkbox"
                            });
                        }
                    }
                    break;
                case "Backspace":
                    event.preventDefault();
                    if (history.length > 0) {
                        const previous = history.pop();
                        elements = previous.tabs || [];
                        categories = previous.categories;
                        categoryIndex = previous.categoryIndex || 0;
                        selectedIndex = previous.selectedIndex || 0;
                        updateMenu();
                        
                        sendToLua("menuAction", {
                            action: "goBack"
                        });
                    } else {
                        showMenu(false);
                        sendToLua("closeMenu", {});
                    }
                    break;
                case "q":
                    event.preventDefault();
                    event.stopPropagation();
                    // Q key: Navigate tabs left (like old version)
                    // First check if we have categories to navigate
                    if (categories && categories.length > 1) {
                        categoryIndex = (categoryIndex - 1 + categories.length) % categories.length;
                        elements = categories[categoryIndex].tabs || [];
                        selectedIndex = 0;
                        updateMenu();
                        sendToLua("menuAction", {
                            action: "categoryChange",
                            categoryIndex: categoryIndex
                        });
                    }
                    // If no categories, handle scrollable if on one
                    else {
                        const qSelected = elements[selectedIndex];
                        if (qSelected && (qSelected.type === "scrollable" || qSelected.type === "scrollable-checkbox")) {
                            if (qSelected.options && qSelected.options.length > 0) {
                                const currentSelected = qSelected.selected !== undefined ? qSelected.selected : 0;
                                qSelected.selected = Math.max(0, currentSelected - 1);
                                qSelected.value = qSelected.selected + 1; // 1-based for compatibility
                                updateMenu();
                            }
                        }
                    }
                    break;
                case "e":
                    event.preventDefault();
                    event.stopPropagation();
                    // E key: Navigate tabs right (like old version, matching Q behavior)
                    // First check if we have categories to navigate
                    if (categories && categories.length > 1) {
                        categoryIndex = (categoryIndex + 1) % categories.length;
                        elements = categories[categoryIndex].tabs || [];
                        selectedIndex = 0;
                        updateMenu();
                        sendToLua("menuAction", {
                            action: "categoryChange",
                            categoryIndex: categoryIndex
                        });
                    }
                    // If no categories, handle scrollable if on one
                    else {
                        const eSelected = elements[selectedIndex];
                        if (eSelected && (eSelected.type === "scrollable" || eSelected.type === "scrollable-checkbox")) {
                            if (eSelected.options && eSelected.options.length > 0) {
                                const currentSelected = eSelected.selected !== undefined ? eSelected.selected : 0;
                                eSelected.selected = Math.min(eSelected.options.length - 1, currentSelected + 1);
                                eSelected.value = eSelected.selected + 1; // 1-based for compatibility
                                updateMenu();
                            }
                        }
                    }
                    break;
                case "ArrowLeft":
                    event.preventDefault();
                    event.stopPropagation();
                    const leftSelected = elements[selectedIndex];
                    if (leftSelected) {
                        // Handle slider
                        if (leftSelected.type === "slider" || leftSelected.type === "slider-checkbox") {
                            const step = leftSelected.step || 1;
                            const min = leftSelected.min || 0;
                            leftSelected.value = Math.max(min, (leftSelected.value || min) - step);
                            updateMenu();
                        }
                        // Handle scrollable
                        else if (leftSelected.type === "scrollable" || leftSelected.type === "scrollable-checkbox") {
                            if (leftSelected.options && leftSelected.options.length > 0) {
                                const currentSelected = leftSelected.selected !== undefined ? leftSelected.selected : 0;
                                leftSelected.selected = Math.max(0, currentSelected - 1);
                                leftSelected.value = leftSelected.selected + 1; // 1-based for compatibility
                                updateMenu();
                            }
                        }
                        // Navigate categories
                        else if (categories && categories.length > 1) {
                            categoryIndex = (categoryIndex - 1 + categories.length) % categories.length;
                            elements = categories[categoryIndex].tabs || [];
                            selectedIndex = 0;
                            updateMenu();
                        }
                    }
                    break;
                case "ArrowRight":
                    event.preventDefault();
                    event.stopPropagation();
                    const rightSelected = elements[selectedIndex];
                    if (rightSelected) {
                        // Handle slider
                        if (rightSelected.type === "slider" || rightSelected.type === "slider-checkbox") {
                            const step = rightSelected.step || 1;
                            const max = rightSelected.max || 100;
                            rightSelected.value = Math.min(max, (rightSelected.value || 0) + step);
                            updateMenu();
                        }
                        // Handle scrollable
                        else if (rightSelected.type === "scrollable" || rightSelected.type === "scrollable-checkbox") {
                            if (rightSelected.options && rightSelected.options.length > 0) {
                                const currentSelected = rightSelected.selected !== undefined ? rightSelected.selected : 0;
                                rightSelected.selected = Math.min(rightSelected.options.length - 1, currentSelected + 1);
                                rightSelected.value = rightSelected.selected + 1; // 1-based for compatibility
                                updateMenu();
                            }
                        }
                        // Navigate categories
                        else if (categories && categories.length > 1) {
                            categoryIndex = (categoryIndex + 1) % categories.length;
                            elements = categories[categoryIndex].tabs || [];
                            selectedIndex = 0;
                            updateMenu();
                        }
                    }
                    break;
            }
        }
        
        function updateMenu() {
            try {
                if (!Array.isArray(elements)) {
                    elements = [];
                }
                
                // Update highlight FIRST - instant response
                updateHighlight();
                
                // Render everything else
                renderTabs();
                renderCategories();
                renderMetadata();
                renderDescription();
                
                // Highlight already updated, no need to update again
            } catch (error) {
                console.error("Error updating menu:", error);
            }
        }
        
        // ===================== MESSAGE HANDLER =====================
        // Handle messages from MachoCreateDui (via window.addEventListener)
        window.addEventListener('message', (event) => {
            let data = event.data;
            
            // Handle string JSON from MachoSendDuiMessage
            if (typeof data === "string") {
                try {
                    data = JSON.parse(data);
                } catch (e) {
                    console.error("Failed to parse message data:", e);
                    return;
                }
            }
            
            if (!data || typeof data !== "object") {
                console.warn("[Motion.Lua] Invalid data received:", data);
                return;
            }
            
            console.log("[Motion.Lua] Received message:", data.action, data);
            
            if (data.action === "showUI") {
                console.log("[Motion.Lua] showUI action, visible:", data.visible);
                showMenu(!!data.visible);
                
                if (data.visible) {
                    // Force show menu wrapper
                    const wrapper = document.getElementById('menuWrapper');
                    if (wrapper) {
                        wrapper.style.display = 'flex';
                        wrapper.style.visibility = 'visible';
                        wrapper.style.opacity = '1';
                        wrapper.classList.add('show');
                    }
                    
                    // CRITICAL: Handle elements - check if it's an array or needs flattening
                    let elementsToUse = [];
                    if (data.elements) {
                        if (Array.isArray(data.elements)) {
                            // Check if elements are nested (categories/tabs structure) - MAIN MENU TABS
                            if (data.elements.length > 0 && data.elements[0].categories) {
                                // For main menu, use the top-level tabs directly (Self, Server, etc.)
                                console.log("[Motion.Lua] Main menu structure detected, using top-level tabs");
                                elementsToUse = data.elements; // Use tabs directly, HTML will handle submenus
                            } else {
                                // Direct array of elements (already flattened)
                                elementsToUse = data.elements;
                            }
                        }
                    }
                    
                    if (elementsToUse.length > 0) {
                        elements = elementsToUse;
                        console.log(`[Motion.Lua] Using ${elements.length} elements (type: ${elements[0]?.type || 'unknown'})`);
                        if (typeof data.index === "number" && data.index >= 0 && data.index < elements.length) {
                            selectedIndex = data.index;
                        } else {
                            selectedIndex = 0;
                        }
                    } else {
                        console.warn("[Motion.Lua] No elements to use after processing");
                        elements = [];
                        selectedIndex = 0;
                    }
                    
                    if (typeof data.username !== "undefined") {
                        username = data.username;
                    }
                    
                    if (data.bannerLink) {
                        banner.link = data.bannerLink;
                        const img = document.getElementById('bannerImage');
                        if (img) img.src = data.bannerLink;
                    }
                    
                    if (data.bannerColor) {
                        banner.color = data.bannerColor;
                        document.documentElement.style.setProperty('--menu-color', data.bannerColor);
                    }
                    
                    if (data.highlightColor) {
                        banner.highlightColor = data.highlightColor;
                        document.documentElement.style.setProperty('--select-blue', data.highlightColor);
                    }
                    
                    // Reset history when opening menu
                    history = [];
                    
                    // Force update menu immediately
                    console.log("[Motion.Lua] Calling updateMenu() with", elements.length, "elements");
                    updateMenu();
                    updateHighlight();
                    
                    // Also update after a small delay to ensure DOM is ready
                    setTimeout(() => {
                        console.log("[Motion.Lua] Delayed updateMenu() call");
                        updateMenu();
                        updateHighlight();
                    }, 100);
                } else {
                    // Hide menu
                    const wrapper = document.getElementById('menuWrapper');
                    if (wrapper) {
                        wrapper.style.opacity = '0';
                        wrapper.classList.remove('show');
                        setTimeout(() => {
                            wrapper.style.visibility = 'hidden';
                        }, 300);
                    }
                }
            }
            
            if (data.action === "updateBanner") {
                if (data.bannerLink) {
                    banner.link = data.bannerLink;
                    const img = document.getElementById('bannerImage');
                    if (img) img.src = data.bannerLink;
                }
                if (data.bannerColor) {
                    banner.color = data.bannerColor;
                    document.documentElement.style.setProperty('--menu-color', data.bannerColor);
                }
                if (data.highlightColor) {
                    banner.highlightColor = data.highlightColor;
                    document.documentElement.style.setProperty('--select-blue', data.highlightColor);
                }
                // Update highlight immediately
                updateHighlight();
            }
            
            if (data.action === "updateTheme") {
                if (data.bannerLink) {
                    banner.link = data.bannerLink;
                    const img = document.getElementById('bannerImage');
                    if (img) img.src = data.bannerLink;
                }
                if (data.bannerColor) {
                    banner.color = data.bannerColor;
                    document.documentElement.style.setProperty('--menu-color', data.bannerColor);
                }
                if (data.highlightColor) {
                    banner.highlightColor = data.highlightColor;
                    document.documentElement.style.setProperty('--select-blue', data.highlightColor);
                }
                // Update highlight immediately
                updateHighlight();
            }
            
            if (data.action === "updateElements") {
                if (data.elements && Array.isArray(data.elements)) {
                    elements = data.elements;
                } else {
                    elements = [];
                }
                
                if (typeof data.index === "number" && data.index >= 0 && data.index < elements.length) {
                    selectedIndex = data.index;
                } else {
                    selectedIndex = 0;
                }
                
                if (data.categories && Array.isArray(data.categories)) {
                    categories = data.categories;
                    categoryIndex = (typeof data.categoryIndex === "number" && data.categoryIndex >= 0 && data.categoryIndex < categories.length) 
                        ? data.categoryIndex 
                        : 0;
                } else {
                    categories = null;
                    categoryIndex = 0;
                }
                
                updateMenu();
                updateHighlight();
            }
            
            // Handle setCurrent action (from DUI menu system)
            if (data.action === "setCurrent") {
                playUiTick();
                if (data.menu && Array.isArray(data.menu)) {
                    elements = data.menu;
                }
                if (typeof data.current === "number" && data.current >= 0 && data.current < elements.length) {
                    selectedIndex = data.current;
                }
                updateMenu();
            }
            
            if (data.action === "updateKeyboard") {
                const wrapper = document.getElementById('inputWrapper');
                const overlay = document.getElementById('overlay');
                const title = document.getElementById('inputTitle');
                const value = document.getElementById('inputValue');
                
                if (data.visible) {
                    if (wrapper) wrapper.classList.add('show');
                    if (overlay) overlay.classList.add('show');
                    if (title) title.textContent = data.title || "Keyboard Input";
                    if (value) value.textContent = data.value || "Value";
                } else {
                    if (wrapper) wrapper.classList.remove('show');
                    if (overlay) overlay.classList.remove('show');
                }
            }
            
            if (data.action === "showTextInput") {
                showTextInputModal(data.question || "Enter text", data.placeholder || "", data.maxLength || 50, data.inputType || "alphanumeric", data.callback || "");
            }
            
            if (data.action === "showNotification") {
                showNotification(data.type || "info", data.title || "Notification", data.desc || "", data.duration || 4000);
            }


// Support legacy action name from Lua ("notification")
if (data.action === "notification") {
    showNotification(
        data.type || "info",
        data.title || "Notification",
        data.message || data.desc || "",
        data.duration || 4000
    );
}
            
            if (data.action === "displayBinds") {
                const container = document.getElementById('keybindsContainer');
                if (container) {
                    if (data.visible) {
                        container.classList.add('show');
                    } else {
                        container.classList.remove('show');
                    }
                }
                
                if (data.binds) {
                    const list = document.getElementById('keybindsList');
                    if (list) {
                        list.innerHTML = data.binds.map(bind => `
                            <div class="Keybind">
                                <div class="Label">${bind.label}</div>
                                <div class="Elements">
                                    <span>${(bind.type === "checkbox" || bind.type === "slider-checkbox") ? `(${bind.keyLabel})` : bind.keyLabel}</span>
                                    ${(bind.type === "checkbox" || bind.type === "slider-checkbox") ? `
                                        <span style="color: ${bind.checked ? 'white' : 'rgba(255, 255, 255, 0.50)'}">
                                            ${bind.checked ? 'On' : 'Off'}
                                        </span>
                                    ` : ''}
                                </div>
                            </div>
                        `).join('');
                    }
                }
            }
        });
        
        // Text Input Modal Function
        let textInputModal = null;
        let textInputCallback = null;
        
        function showTextInputModal(question, placeholder, maxLength, inputType, callback) {
            // Allow mouse ONLY while the modal is open (parent pointer-events must be enabled)
            document.body.style.pointerEvents = 'auto';
            document.body.style.cursor = 'auto';

            // Remove existing modal if any
            if (textInputModal) {
                textInputModal.remove();
            }
            
            textInputCallback = callback;
            
            // Create modal
            textInputModal = document.createElement('div');
            textInputModal.className = 'TextInputModal';
            textInputModal.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.95);
                border: 2px solid rgba(var(--menu-color), 1);
                border-radius: 0.5vw;
                padding: 1.5vw;
                z-index: 10000;
                min-width: 25vw;
                box-shadow: 0 0 2vw rgba(var(--menu-color), 0.5);
                opacity: 0;
                transition: opacity 0.2s ease;
                pointer-events: auto !important;
                cursor: auto !important;
            `;
            
            // Animate in
            setTimeout(() => {
                if (textInputModal) {
                    textInputModal.style.opacity = '1';
                }
            }, 10);
            
            textInputModal.innerHTML = `
                <div style="margin-bottom: 1vw; font-size: 1vw; color: #fff; font-weight: 500;">${question}</div>
                <input type="text" id="textInputField" placeholder="${placeholder}" maxlength="${maxLength}" style="
                    width: 100%;
                    padding: 0.5vw;
                    background: rgba(255, 255, 255, 0.1);
                    border: 1px solid rgba(var(--menu-color), 0.5);
                    border-radius: 0.25vw;
                    color: #fff;
                    font-size: 0.9vw;
                    outline: none;
                " autofocus>
                <div style="margin-top: 1vw; display: flex; gap: 0.5vw; justify-content: flex-end;">
                    <button id="textInputCancel" style="
                        padding: 0.5vw 1vw;
                        background: rgba(255, 0, 0, 0.3);
                        border: 1px solid rgba(255, 0, 0, 0.5);
                        border-radius: 0.25vw;
                        color: #fff;
                        cursor: pointer;
                        font-size: 0.9vw;
                    ">Cancel</button>
                    <button id="textInputSubmit" style="
                        padding: 0.5vw 1vw;
                        background: rgba(var(--menu-color), 0.5);
                        border: 1px solid rgba(var(--menu-color), 1);
                        border-radius: 0.25vw;
                        color: #fff;
                        cursor: pointer;
                        font-size: 0.9vw;
                    ">Submit</button>
                </div>
            `;
            
            document.body.appendChild(textInputModal);
            
            const inputField = document.getElementById('textInputField');
            const submitBtn = document.getElementById('textInputSubmit');
            const cancelBtn = document.getElementById('textInputCancel');
            
            // Focus input
            setTimeout(() => inputField.focus(), 100);
            
            // Submit on Enter
            inputField.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    submitTextInput();
                } else if (e.key === 'Escape') {
                    cancelTextInput();
                }
            });
            
            // Submit button
            submitBtn.addEventListener('click', submitTextInput);
            
            // Cancel button
            cancelBtn.addEventListener('click', cancelTextInput);
            
            function submitTextInput() {
                const value = inputField.value.trim();
                if (value) {
                    // Store in global variable for Lua to poll
                    window._textInputResult = {
                        callback: callback,
                        value: value
                    };
                    // Also send via sendToLua
                    sendToLua("textInputResult", {
                        callback: callback,
                        value: value
                    });
                }
                cancelTextInput();
            }
            
            function cancelTextInput() {
                if (textInputModal) {
                    textInputModal.style.opacity = '0';
                    textInputModal.style.transition = 'opacity 0.2s ease';
                    setTimeout(() => {
                        if (textInputModal) {
                            textInputModal.remove();
                            textInputModal = null;
                        }
                    }, 200);
                }
                // Re-lock mouse for the menu (keyboard-only)
                document.body.style.pointerEvents = 'none';
                document.body.style.cursor = 'none';
                textInputCallback = null;
            }
        }
        
        // ===================== NOTIFICATIONS =====================
        
function showNotification(type, title, desc, duration) {
            playUiTick();
    const container = document.getElementById('notificationsContainer');
    if (!container) return;

    const id = notificationId++;

    // Always neon purple (as requested), keep type only for icon choice
    const accentRaw = getComputedStyle(document.documentElement).getPropertyValue('--notif-accent').trim();
    const accent = accentRaw ? `rgb(${accentRaw})` : 'rgb(180, 0, 255)';

    const icon =
        type === "success" ? "fa-circle-check" :
        type === "error"   ? "fa-circle-xmark" :
        type === "warning" ? "fa-triangle-exclamation" :
                             "fa-circle-info";

    const notif = document.createElement('div');
    notif.className = 'Notification';
    notif.id = `notif-${id}`;
    notif.innerHTML = `
        <div class="NotificationBorder" style="background-color: ${accent};"></div>
        <i class="fa-solid ${icon}" style="color: ${accent};"></i>
        <div class="NotificationContent">
            <div class="NotificationTitle">${title}</div>
            <div class="NotificationDesc">${desc}</div>
        </div>
        <div class="NotificationProgress" style="background-color: ${accent}; animation-duration: ${duration}ms;"></div>
    `;

    container.appendChild(notif);

    requestAnimationFrame(() => {
        notif.offsetWidth;
        notif.classList.add('enter');
    });

    setTimeout(() => {
        notif.classList.remove('enter');
        notif.classList.add('exit');
        setTimeout(() => {
            if (notif.parentNode) notif.parentNode.removeChild(notif);
        }, 500);
    }, duration);
}

        // Handle slider and scrollable controls with arrow keys
        function handleSliderControl(direction) {
            const selected = elements[selectedIndex];
            if (!selected) return;
            
            if (selected.type === "slider" || selected.type === "slider-checkbox") {
                const step = selected.step || 1;
                const min = selected.min || 0;
                const max = selected.max || 100;
                let newValue = selected.value || min;
                
                if (direction === "left") {
                    newValue = Math.max(min, newValue - step);
                } else if (direction === "right") {
                    newValue = Math.min(max, newValue + step);
                }
                
                selected.value = newValue;
                updateMenu();
            } else if (selected.type === "scrollable" || selected.type === "scrollable-checkbox") {
                if (!selected.values || selected.values.length === 0) return;
                
                let newIndex = selected.value || 0;
                if (direction === "left") {
                    newIndex = Math.max(0, newIndex - 1);
                } else if (direction === "right") {
                    newIndex = Math.min(selected.values.length - 1, newIndex + 1);
                }
                
                selected.value = newIndex;
                updateMenu();
            }
        }
        
        // Enhanced keyboard handler with slider support
        function enhancedKeyHandler(event) {
            if (!menuVisible) return;
            
            // Skip if typing in input
            if (document.activeElement && document.activeElement.tagName === 'INPUT') {
                return;
            }
            
            // Handle Left/Right for sliders and categories
            if (event.key === "ArrowLeft") {
                event.preventDefault();
                event.stopPropagation();
                const selected = elements[selectedIndex];
                if (selected && (selected.type === "slider" || selected.type === "slider-checkbox" || selected.type === "scrollable" || selected.type === "scrollable-checkbox")) {
                    handleSliderControl("left");
                } else if (categories && categories.length > 1) {
                    categoryIndex = (categoryIndex - 1 + categories.length) % categories.length;
                    elements = categories[categoryIndex].tabs || [];
                    selectedIndex = 0;
                    updateMenu();
                }
                return;
            }
            
            if (event.key === "ArrowRight") {
                event.preventDefault();
                event.stopPropagation();
                const selected = elements[selectedIndex];
                if (selected && (selected.type === "slider" || selected.type === "slider-checkbox" || selected.type === "scrollable" || selected.type === "scrollable-checkbox")) {
                    handleSliderControl("right");
                } else if (categories && categories.length > 1) {
                    categoryIndex = (categoryIndex + 1) % categories.length;
                    elements = categories[categoryIndex].tabs || [];
                    selectedIndex = 0;
                    updateMenu();
                }
                return;
            }
            
            // Handle other keys with original handler
            handleKeyDown(event);
        }
        
        // ===================== MOUSE EVENT DISABLING =====================
        // STRICTLY KEYBOARD-ONLY MENU - ALL MOUSE INPUT COMPLETELY REMOVED
        // Block ALL mouse events - no exceptions for menu navigation
        
        // Block mouse wheel completely
        document.addEventListener('wheel', (e) => {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            e.cancelBubble = true;
            return false;
        }, { passive: false, capture: true });
        
        // Block ALL mouse movement - no navigation via mouse
        document.addEventListener('mousemove', (e) => {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            e.cancelBubble = true;
            return false;
        }, { passive: false, capture: true });
        
        // Block ALL mouse clicks - menu is keyboard-only
        document.addEventListener('mousedown', (e) => {
            // ONLY allow clicks on text input modal (for text input functionality)
            const isTextInputModal = e.target.closest('.TextInputModal');
            const isInput = e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON';
            
            // Block everything except text input modal
            if (!isTextInputModal || !isInput) {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                e.cancelBubble = true;
                return false;
            }
        }, { passive: false, capture: true });
        
        document.addEventListener('click', (e) => {
            // ONLY allow clicks on text input modal (for text input functionality)
            const isTextInputModal = e.target.closest('.TextInputModal');
            const isInput = e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON';
            
            // Block everything except text input modal
            if (!isTextInputModal || !isInput) {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                e.cancelBubble = true;
                return false;
            }
        }, { passive: false, capture: true });
        
        // Block ALL right clicks
        document.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            e.cancelBubble = true;
            return false;
        }, { passive: false, capture: true });
        
        document.addEventListener('mouseup', (e) => {
            // ONLY allow clicks on text input modal (for text input functionality)
            const isTextInputModal = e.target.closest('.TextInputModal');
            const isInput = e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON';
            
            // Block everything except text input modal
            if (!isTextInputModal || !isInput) {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                e.cancelBubble = true;
                return false;
            }
        }, { passive: false, capture: true });
        
        // Block ALL hover events - no hover-based navigation
        document.addEventListener('mouseenter', (e) => {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            e.cancelBubble = true;
            return false;
        }, { capture: true, passive: false });
        
        document.addEventListener('mouseleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            e.cancelBubble = true;
            return false;
        }, { capture: true, passive: false });
        
        // Block ALL mouseover/mouseout - no hover effects
        document.addEventListener('mouseover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            e.cancelBubble = true;
            return false;
        }, { capture: true, passive: false });
        
        document.addEventListener('mouseout', (e) => {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            e.cancelBubble = true;
            return false;
        }, { capture: true, passive: false });
        
        // Disable cursor completely - no mouse cursor
        document.body.style.cursor = 'none';
        document.body.style.pointerEvents = 'none';
        
        // Make entire menu keyboard-only - selection ONLY changes via keyboard
        // No mouse interaction with menu elements whatsoever
        
        // ===================== INITIALIZATION =====================
        // In-game: ALL navigation is handled in Lua (FiveM controls).
        // Only enable keyboard navigation in browser preview/testing.
        if (isEnvBrowser()) {
            window.addEventListener('keydown', enhancedKeyHandler);
        }
        
        // Initialize menu - hidden by default (Lua will send showUI)
        (function init() {
            const wrapper = document.getElementById('menuWrapper');
            if (wrapper) {
                wrapper.style.display = 'none';
                wrapper.style.visibility = 'hidden';
                wrapper.style.opacity = '0';
                wrapper.classList.remove('show');
                menuVisible = false;
            }
            elements = [];
            selectedIndex = 0;
        })();
        
        // Browser mode for testing
        if (isEnvBrowser()) {
            const root = document.getElementById('root');
            if (root) {
                root.style.backgroundImage = 'url("https://files.catbox.moe/cplsay.png")';
                root.style.backgroundSize = 'cover';
                root.style.backgroundRepeat = 'no-repeat';
                root.style.backgroundPosition = 'center';
            }
            
            // Show menu in browser for testing
            setTimeout(() => {
                showMenu(true);
                elements = [];
                selectedIndex = 0;
                updateMenu();
            }, 100);
        }
    </script>
  </body>
</html>
